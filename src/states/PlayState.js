import e from "../../lib/State.js"; import t from "../objects/Level.js"; import l from "../entities/Player.js"; import i from "../services/Map.js"; import s from "../enums/ImageName.js"; import r from "../enums/SoundName.js"; import a from "../enums/EnemyType.js"; import h from "../entities/EnemyFactory.js"; import m from "../../lib/Sprite.js"; import { images as n, stateMachine as o, sounds as p, context as v, CANVAS_HEIGHT as c, CANVAS_WIDTH as u, keys as y } from "../globals.js"; import f from "../../lib/Animation.js"; import d from "../services/SaveManager.js"; import b from "../enums/GameStateName.js"; import S from "../services/LevelMaker.js"; import _ from "../user-interface/HealthBar.js"; export default class j extends e { constructor(e) { super(), this.levelNumber = 1, this.entered = !1, this.win = !1 } enter(e) { if (this.levelComplete = !1, p.stop(r.LeFestin), this.entered = !0, this.win && (this.levelNumber = 1, this.win = !1), this.music = S.LEVEL_MUSIC[this.levelNumber - 1], this.newGameOptionSelected = e.newGameOptionSelected, e.newGameOptionSelected) this.player = e.player ?? new l, this.level = S.createLevel(this.player, this.levelNumber); else { this.level = d.loadData, this.newGameOptionSelected = !0, this.levelNumber = d.loadLevel(); for (let t = 0; t < this.level.entities.length; t++)this.level.entities[t] instanceof l && (this.player = this.level.entities[t], this.level.player = this.player), this.level.entities[t].setLevelOnStates(this.level); for (let i = 0; i < this.level.tables.length; i++)this.level.tables[i].level = this.level; this.level.playerHealthbar = new _(u - 170, 11, this.player, 128, 10), this.newGameOptionSelected = !0 } p.play(this.music) } exit() { p.stop(this.music) } async update(e) { this.level.update(e), 1 !== this.level.entities.length || this.level.entities[0] !== this.level.player || this.levelComplete || (this.levelComplete = !0, p.stop(this.music), p.play(r.LevelComplete)), this.level.isGameOver && (this.player.currentHealth = l.MAX_HEALTH, this.player.cleanUp = !1, this.player.isDead = !1, this.player.table = null, this.levelNumber = 1, o.change(b.GameOver)), this.level.isVictory && (this.levelNumber === S.FINAL_LEVEL ? (this.player.currentHealth = l.MAX_HEALTH, this.player.table = null, this.win = !0, o.change(b.Transition, { fromState: this, toState: o.states[b.Victory] })) : (this.levelNumber++, this.player.table = null, this.entered = !1, o.change(b.Transition, { fromState: this, toState: o.states[b.Play], toStateEnterParameters: { newGameOptionSelected: this.newGameOptionSelected, player: this.player } }))), (y.p || y.P) && (console.log("saved"), y.p = !1, y.P = !1, await d.saveGame(this), console.log(await d.loadGame()), d.saveLevel(this.levelNumber)) } render() { n.render(s.Map, 0, 0, u, c), this.level.render(), v.fillStyle = "white", v.font = "25px Anarchaos", v.fillText(`Night #${this.entered ? this.levelNumber : this.levelNumber - 1}`, 25, 20) } };