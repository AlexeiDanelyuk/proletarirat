import e from "../../../../lib/Animation.js"; import { didSucceedPercentChance as t, getRandomPositiveInteger as i, pickRandomElement as n } from "../../../../lib/RandomNumberHelpers.js"; import s from "../../../../lib/State.js"; import o from "../../../entities/Enemy.js"; import m from "../../../enums/Direction.js"; import r from "../../../enums/EnemyStateName.js"; import { timer as h } from "../../../globals.js"; export default class y extends s { static IDLE_CHANCE = .5; static MOVE_DURATION_MIN = 2; static MOVE_DURATION_MAX = 6; constructor(e, t) { super(), this.enemy = e, this.animation = t } toJSON() { let e = {}, t = Object.keys(this.animation); for (let i = 0; i < t.length; i++)e[t[i]] = this.animation[i].toJSON(); return { animation: e, className: this.constructor.name } } static buildObject(t, i) { t.animation = { [m.Up]: new e([0, 4, 8, 12], .2), [m.Down]: new e([1, 5, 9, 13], .2), [m.Left]: new e([3, 7, 11, 15], .2), [m.Right]: new e([2, 6, 10, 14], .2) }; for (let n = 0; n < t.animation.length; n++)t.animation[n].startTimer(); return t.enemy = i, Object.setPrototypeOf(t, y.prototype) } enter() { this.enemy.currentAnimation = this.animation[this.enemy.direction], this.reset(), this.startTimer() } update(e) { this.move(e), this.timer.update(e), this.enemy.getDistanceToPlayer() <= o.CHASE_DISTANCE && this.enemy.changeState(r.Chasing) } startTimer() { this.timer = h.wait(4, () => this.decideMovement()) } decideMovement() { t(y.IDLE_CHANCE) ? this.enemy.changeState(r.Idle) : (this.reset(), this.startTimer()) } reset() { this.enemy.direction = n([m.Up, m.Down, m.Left, m.Right]), this.enemy.currentAnimation = this.animation[this.enemy.direction], this.moveDuration = i(y.MOVE_DURATION_MIN, y.MOVE_DURATION_MAX) } move(e) { this.enemy.direction === m.Down ? (this.enemy.position.y += this.enemy.speed * e, this.enemy.position.y + this.enemy.dimensions.y > 316 && (this.enemy.position.y = 316 - this.enemy.dimensions.y, this.reset())) : this.enemy.direction === m.Right ? (this.enemy.position.x += this.enemy.speed * e, this.enemy.position.x + this.enemy.dimensions.x > 448 && (this.enemy.position.x = 448 - this.enemy.dimensions.x, this.reset())) : this.enemy.direction === m.Up ? (this.enemy.position.y -= this.enemy.speed * e, this.enemy.position.y < 86 - this.enemy.dimensions.y / 2 && (this.enemy.position.y = 86 - this.enemy.dimensions.y / 2, this.reset())) : this.enemy.direction === m.Left && (this.enemy.position.x -= this.enemy.speed * e, this.enemy.position.x < 32 && (this.enemy.position.x = 32, this.reset())) } isValidMove(e, t) { return null === this.enemy.map.collisionLayer.getTile(e, t) } };