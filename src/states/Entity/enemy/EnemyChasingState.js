import i from "../../../../lib/Animation.js"; import { didSucceedPercentChance as e, getRandomPositiveInteger as t, pickRandomElement as n } from "../../../../lib/RandomNumberHelpers.js"; import s from "../../../../lib/State.js"; import o from "../../../../lib/Vector.js"; import m from "../../../entities/Enemy.js"; import r from "../../../enums/Direction.js"; import h from "../../../enums/EnemyStateName.js"; import { timer as a } from "../../../globals.js"; import y from "../../../objects/Bullet.js"; export default class c extends s { static IDLE_CHANCE = .5; static MOVE_DURATION_MIN = 2; static MOVE_DURATION_MAX = 6; constructor(i, e, t, n) { super(), this.enemy = i, this.animation = e, this.idleAnimation = t, this.x_direction = r.Right, this.y_direction = r.Down, this.previousDirection = this.x_direction, this.level = n, this.counter = 1, this.rateOfFire = i.rateOfFire } toJSON() { return { animation: this.getAnimationObject(this.animation), idleAnimation: this.getAnimationObject(this.idleAnimation), x_direction: this.x_direction, y_direction: this.y_direction, previousDirection: this.previousDirection, counter: this.counter, className: this.constructor.name } } static buildObject(e, t) { e.animation = { [r.Up]: new i([0, 4, 8, 12], .2), [r.Down]: new i([1, 5, 9, 13], .2), [r.Left]: new i([3, 7, 11, 15], .2), [r.Right]: new i([2, 6, 10, 14], .2) }, e.idleAnimation = { [r.Up]: new i([0], 1), [r.Down]: new i([1], 1), [r.Left]: new i([3], 1), [r.Right]: new i([2], 1) }; for (let n = 0; n < e.animation.length; n++)e.animation[n].startTimer(), e.idleAnimation[n].startTimer(); return e.enemy = t, e.rateOfFire = t.rateOfFire, Object.setPrototypeOf(e, c.prototype) } getAnimationObject(i, e) { let t = {}, n = Object.keys(i); for (let s = 0; s < n.length; s++)t[parseInt(n[s])] = i[s].toJSON(); return t } enter() { this.decideDirections(), this.enemy.currentAnimation = this.animation[this.x_direction] } update(i) { this.decideDirections(), this.move(i), this.counter++, this.counter % this.rateOfFire == 0 && this.level.addObject(new y(this.enemy, new o(this.level.player.position.x + 10, this.level.player.position.y + 10))) } decideDirections() { this.enemy.getDistanceToPlayer() > m.CHASE_DISTANCE && this.enemy.changeState(h.EnemyWalkingState), this.enemy.x_distance < 0 ? this.x_direction = r.Right : this.x_direction = r.Left, this.enemy.y_distance < 0 ? this.y_direction = r.Down : this.y_direction = r.Up } reset() { this.moveDuration = t(EnemyWalkingState.MOVE_DURATION_MIN, EnemyWalkingState.MOVE_DURATION_MAX) } move(i) { if (Math.abs(this.enemy.x_distance) > Math.abs(this.enemy.y_distance) + 10 ? this.enemy.direction = this.x_direction : Math.abs(this.enemy.y_distance) > Math.abs(this.enemy.x_distance) + 10 ? this.enemy.direction = this.y_direction : this.enemy.direction = this.x_direction, this.previousDirection !== this.enemy.direction && (this.enemy.currentAnimation = this.animation[this.x_direction], 20 > Math.abs(this.enemy.x_distance) && (this.enemy.currentAnimation = this.animation[this.y_direction])), 40 > this.enemy.getDistanceToPlayer() || this.enemy.isColliding) { this.enemy.currentAnimation = this.idleAnimation[this.x_direction], 20 > Math.abs(this.enemy.x_distance) && (this.enemy.currentAnimation = this.idleAnimation[this.y_direction]); return } this.enemy.currentAnimation = this.animation[this.x_direction], 20 > Math.abs(this.enemy.x_distance) && (this.enemy.currentAnimation = this.animation[this.y_direction]), this.enemy.direction === r.Down ? (this.enemy.position.y += this.enemy.speed * i, this.enemy.position.y + this.enemy.dimensions.y > 316 && (this.enemy.position.y = 316 - this.enemy.dimensions.y)) : this.enemy.direction === r.Right ? (this.enemy.position.x += this.enemy.speed * i, this.enemy.position.x + this.enemy.dimensions.x > 448 && (this.enemy.position.x = 448 - this.enemy.dimensions.x)) : this.enemy.direction === r.Up ? (this.enemy.position.y -= this.enemy.speed * i, this.enemy.position.y < 86 - this.enemy.dimensions.y / 2 && (this.enemy.position.y = 86 - this.enemy.dimensions.y / 2)) : this.enemy.direction === r.Left && (this.enemy.position.x -= this.enemy.speed * i, this.enemy.position.x < 32 && (this.enemy.position.x = 32)) } };