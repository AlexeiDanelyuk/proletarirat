import i from "../../lib/Vector.js"; import { getCollisionDirection as t } from "../../lib/CollisionHelpers.js"; import s from "../../lib/Hitbox.js"; import o from "../enums/Direction.js"; import { context as e, DEBUG as n } from "../globals.js"; export default class h { constructor(i, t, o = new s) { this.dimensions = i, this.position = t, this.hitboxOffsets = o, this.hitbox = new s(this.position.x + this.hitboxOffsets.position.x, this.position.y + this.hitboxOffsets.position.y, this.dimensions.x + this.hitboxOffsets.dimensions.x, this.dimensions.y + this.hitboxOffsets.dimensions.y), this.sprites = [], this.currentFrame = 0, this.cleanUp = !1, this.renderPriority = 0, this.isSolid = !1, this.isCollidable = !1, this.isConsumable = !1, this.wasCollided = !1, this.wasConsumed = !1 } toJSON() { return { dimensions: this.dimensions.toJSON(), position: this.position.toJSON(), hitboxOffsets: this.hitboxOffsets.toJSON(), hitbox: this.hitbox.toJSON(), currentFrame: this.currentFrame, cleanUp: this.cleanUp, renderPriority: this.renderPriority, isSolid: this.isSolid, isCollidable: this.isCollidable, isConsumable: this.isConsumable, wasCollided: this.wasCollided, wasConsumed: this.wasConsumed } } static rebuildObject(t) { return t.dimensions = Object.setPrototypeOf(t.dimensions, i.prototype), t.position = Object.setPrototypeOf(t.position, i.prototype), t.hitboxOffsets = Object.setPrototypeOf(t.hitboxOffsets, s.prototype), t.hitbox = Object.setPrototypeOf(t.hitbox, s.prototype), Object.setPrototypeOf(t, h.prototype) } update(i) { } render(i = { x: 0, y: 0 }) { let t = this.position.x + i.x, s = this.position.y + i.y; this.sprites[this.currentFrame].render(Math.floor(t), Math.floor(s)), n && this.hitbox.render(e) } onConsume(i) { this.wasConsumed = !0 } onCollision(i) { if (this.isSolid) { let t = this.getEntityCollisionDirection(i.hitbox); switch (t) { case o.Up: i.position.y = this.hitbox.position.y - Math.abs(i.position.y - i.hitbox.position.y) - i.hitbox.dimensions.y; break; case o.Down: i.position.y = this.hitbox.position.y + this.hitbox.dimensions.y - Math.abs(i.position.y - i.hitbox.position.y); break; case o.Left: i.position.x = this.hitbox.position.x - Math.abs(i.position.x - i.hitbox.position.x) - i.hitbox.dimensions.x; break; case o.Right: i.position.x = this.hitbox.position.x + this.hitbox.dimensions.x - Math.abs(i.position.x - i.hitbox.position.x) } } !this.wasCollided && (this.wasCollided = !0) } didCollideWithEntity(i) { return this.hitbox.didCollide(i) } getEntityCollisionDirection(i) { return t(this.hitbox.position.x, this.hitbox.position.y, this.hitbox.dimensions.x, this.hitbox.dimensions.y, i.position.x, i.position.y, i.dimensions.x, i.dimensions.y) } };