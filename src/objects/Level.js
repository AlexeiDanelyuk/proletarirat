import { didSucceedPercentChance as e, getRandomPositiveInteger as t } from "../../lib/RandomNumberHelpers.js"; import i from "../../lib/Vector.js"; import s from "./Bullet.js"; import r from "./Table.js"; import h from "../objects/Cheese.js"; import { context as a, CANVAS_HEIGHT as l, CANVAS_WIDTH as o, sounds as n } from "../globals.js"; import d from "../entities/Player.js"; import p from "../enums/EnemyStateName.js"; import c from "../enums/SoundName.js"; import b from "../user-interface/HealthBar.js"; import y from "./Bread.js"; export default class u { constructor(e, t, s) { e.stateMachine = e.initializeStateMachine(this), t.forEach(e => { e.initializeStateMachine(this) }), this.player = e, this.tiles = [], this.entities = [], this.objects = [], this.entities.push(e), this.entities.push(...t), this.renderQueue = [], this.isGameOver = !1, this.isVictory = !1, this.tables = []; for (let h = 0; h < s.length; h++)this.tables.push(new r(new i(64, 64), s[h], this)); this.healthdrops = [], this.playerHealthbar = new b(o - 170, 11, this.player, 128, 10) } toJSON() { return { tiles: this.tiles, entities: this.entities, objects: this.objects, renderQueue: this.renderQueue, tables: this.tables, healthdrops: this.healthdrops, player: this.player.toJSON(), isGameOver: this.isGameOver, isVictory: this.isVictory, className: this.constructor.name } } update(e) { this.renderQueue = this.buildRenderQueue(), this.healthdrops.forEach(t => { t.update(e) }), this.cleanUpEntitiesAndObjects(), this.updateEntities(e), this.updateObjects(e), this.tables.forEach(t => { t.update(e) }) } buildRenderQueue() { return [...this.entities, ...this.objects].sort((e, t) => { let i = 0, s = e.hitbox.position.y + e.hitbox.dimensions.y, r = t.hitbox.position.y + t.hitbox.dimensions.y; return e.renderPriority < t.renderPriority ? -1 : e.renderPriority > t.renderPriority ? 1 : s < r ? -1 : 1 }) } render() { this.healthdrops.forEach(e => { e.render() }), this.player.cleanUp || this.player.render(), this.tables.forEach(e => { e !== this.player.table && e.render() }), this.player.isUnderTable && (a.save(), a.globalAlpha = .5, this.player.table?.render(), a.restore()), this.entities.forEach(e => { e !== this.player && e.render() }), this.objects.forEach(e => { e.render() }), a.save(), a.fillStyle = "white", a.font = "20px Anarchaos", a.fillText("You:", o - 200, 20), this.playerHealthbar.render(), a.restore() } cleanUpEntitiesAndObjects() { this.objects = this.objects.filter(e => !e.cleanUp), this.entities = this.entities.filter(e => !e.cleanUp), this.healthdrops = this.healthdrops.filter(e => !e.cleanUp) } updateEntities(s) { this.entities.forEach(t => { if (t.currentHealth <= 0 && (t.cleanUp = !0, t !== this.player ? (n.play(c.EnemyDying), e(.5) && this.entities.length > 2 && this.healthdrops.push(new h(new i(16, 16), new i(t.position.x + 8, t.position.y + 50)))) : this.isGameOver = !0), t.update(s), this.objects.forEach(e => { e.didCollideWithEntity(t.hitbox) && (e.isCollidable || e.isSolid ? e.onCollision(t) : e.isConsumable && t === this.player && e.onConsume(t)) }), !(t instanceof d)) { for (let r = 0; r < this.entities.length; r++)if (!(this.entities[r] instanceof d)) { if (this.entities[r] !== t && t.didCollideWithEntity(this.entities[r].damageBox, !0)) { t.isColliding = !0; break } t.isColliding = !1 } !t.isDead && this.player.didCollideWithEntity(t.damageBox) && (this.player.receiveDamage(t.damage), this.player.onCollision(t, t.damageBox)) } }), 1 !== this.entities.length || this.entities[0] !== this.player || this.containsBread() || this.healthdrops.push(new y(new i(16, 16), new i(t(50, o - 50), t(100, l - 50)))) } containsBread() { for (let e = 0; e < this.healthdrops.length; e++)if (this.healthdrops[e] instanceof y) return !0; return !1 } updateObjects(e) { this.objects.forEach(t => { t.update(e) }), this.player.isUnderTable; for (let t = 0; t < this.tables.length; t++) { if (this.tables[t].didCollideWithEntity(this.player.hitbox)) { this.player.isUnderTable = !0, this.player.table = this.tables[t]; break } this.player.isUnderTable = !1, this.player.table = null } this.healthdrops.forEach(e => { e.didCollideWithEntity(this.player.hitbox) && (e.onCollision(this.player), e instanceof y && (this.isVictory = !0)) }) } renderTiles() { } isLevelCleared() { } addObject(e) { this.objects.push(e) } };